        -:    0:Source:main.c
        -:    0:Graph:main.gcno
        -:    0:Data:main.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:
        -:    3:/**
        -:    4: * @brief process - The largest number of contiguous
        -:    5: * @param f[in] - input file
        -:    6: * @param max_of_identical[out] - number of contiguous
        -:    7: * @return 0
        -:    8: */
        -:    9:
        -:   10:int process(FILE *f, int *max_of_identical);
        -:   11:
        6:   12:int main(void) {
        6:   13:    int max_of_identical = 0;
        -:   14:
        6:   15:    int flag=process(stdin, &max_of_identical);
        -:   16:
        6:   17:    switch(flag)
        -:   18:      {
        -:   19:          case(-1) :
        1:   20:              fprintf(stderr, "BAD INPUT");
        1:   21:              break;
        -:   22:          case 0 :
        5:   23:              printf("\nНаибольшее число подряд идущих: %d\n", max_of_identical);
        5:   24:              break;
        -:   25:      }
        -:   26:
        6:   27:    return 0;
        -:   28:}
        -:   29:
        -:   30://находит наибольшее число подряд идущих элементов последовательности, которые равны друг другу;
        6:   31:int process(FILE *f, int *max_of_identical) {
        6:   32:    int current_element = 0;
        6:   33:    int element_before = 0;
        6:   34:    int max_length_of_identical = 1;
        6:   35:    int temp_max_length_of_identical = 1;
        -:   36:
        -:   37:
        -:   38:
        6:   39:    if ((fscanf(f, "%d", &current_element)) == 1)// -1 нет данныых для ввода
        -:   40:    {
        5:   41:        element_before = current_element;
        -:   42:    }
        -:   43:    else {
        1:   44:        return -1;
        -:   45:    }
        -:   46:
        -:   47:
       26:   48:    while ((fscanf(f, "%d", &current_element)) == 1) {
        -:   49:
       16:   50:        if (current_element == element_before) {
        9:   51:            temp_max_length_of_identical++;
        -:   52:        }
        -:   53:        else {
        7:   54:            temp_max_length_of_identical = 1;
        -:   55:        }
        -:   56:
       16:   57:        if (temp_max_length_of_identical > max_length_of_identical) {
        8:   58:            max_length_of_identical = temp_max_length_of_identical;
        -:   59:        }
        -:   60:
       16:   61:        element_before = current_element;
        -:   62:
        -:   63:    }
        5:   64:    *max_of_identical = max_length_of_identical;
        5:   65:    return 0;
        -:   66:}
